#+title: Straight Emacs with built-in LSP and Tree Sitter
#+author: Azizul Rahman Azizan
#+PROPERTY: header-args:emacs-lisp :tangle ./init.el :mkdirp yes
#+STARTUP: showAll

* Building emacs
  The following are the thing need to build the running emacs on operationg systems

** Debian 13 (trixie-sid)
   # wayland integration for vim, emacs etc
   sudo apt install wl-clipboard
   sudo apt install build-essential
   sudo apt install autoconf
   sudo apt install texinfo
   # set CC=gcc-13 follwoing the jit version downloaded
   sudo apt-get install libgccjit-13-dev
   sudo apt install zlib1g-dev
   sudo apt install wget make gcc libgnutls28-dev pkg-config libncurses-dev
   sudo apt install libgtk-3-dev
   # build with xml support
   apt install libxml2-dev

   # emacs 28 above support pure gtk (pgtk) using wayland + cairo using gtk3
   ./configure --with-json --with-tree-sitter --with-native-compilation --with-pgtk

   # for build vterm
   sudo apt install cmake
   sudo apt install libtool
   sudo apt install libtool-bin

* Elisp variable and function

** Keymaps

   Offload the most used utility in this key map, we could remap this prefix to other if necassary
   when configuration are take by other package.

   #+begin_src emacs-lisp
     ;; personal utility keymap
     (define-prefix-command 'ara-map)
     (global-set-key (kbd "C-c a") 'ara-map)
   #+end_src

** functions
   Collection of functions useful for certain tasks

*** align all table [org-mode]
    Rather than going to each table and execute =C-c C-c= execute this function for current
    org-file.
    #+begin_src emacs-lisp
      (defun ara/align-all-tables ()
	(interactive)
	(org-table-map-tables 'org-table-align 'quietly))
    #+end_src

* Package System Setup
** Advanced package with *straight*

   For using package/plugin with more details controls, we can use *straight* package to download
   the source and build them (this seems to has error).  With git as prerequisite we can track the
   version which make the software stable or fix them if necassary. The following step summarizes
   the usage:
   - make the backup copy of "elpa"
   - add the bootstrap and add interop with *use-package*
   - modify any config with =:ensure= to =:straight=
   - restart emacs

     #+begin_src emacs-lisp
       ;; bootstrap/install straight
       (defvar bootstrap-version)
       (let ((bootstrap-file
	      (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
	     (bootstrap-version 6))
	 (unless (file-exists-p bootstrap-file)
	   (with-current-buffer
	       (url-retrieve-synchronously
		"https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
		'silent 'inhibit-cookies)
	     (goto-char (point-max))
	     (eval-print-last-sexp)))
	 (load bootstrap-file nil 'nomessage))

       ;; install use-package via straight
       (straight-use-package 'use-package)

       ;; set use-package by default to use straight
       (setq straight-use-package-by-default t)

       ;; disable package installation
       (setq package-enable-at-startup nil)
     #+end_src

* Base System Lib Setup
** COMMENT completion (icomplete)
   The basic completion depends on the completion style listed in =completion-styles=; by default
   will match with the initial pattern *basic*, followed by *partial-completion* and then *emacs22*.
   The similar thing are done in *vertico* but with are more useful with default ocnfiguration.
   #+begin_src emacs-lisp
     ;; default icomplete
     (icomplete-vertical-mode)
     (setq completion-auto-wrap t
           completion-auto-select t
           completion-cycling t
           completion-show-help nil
           completion-max-height 15)
   #+end_src
** password store (auth-source-pass)

   This is used to pass encrypted password in *pass* program in startup scripts.
   #+begin_src emacs-lisp
     (use-package auth-source-pass
       :straight (:type built-in))
   #+end_src

   Using the above library with =main.gmail= is registered in *pass* program
   #+begin_src sh :results output :tangle no
     pass
   #+end_src
   
   #+RESULTS:
   : Password Store
   : └── main.gmail

   #+begin_src emacs-lisp :tangle no
     (auth-source-pass-get 'secret "main.gmail")
   #+end_src

** org-mode

   Org-mode will download the repository version for the org-mode and compiled it; however this
   "main" trunk version is not allowed in any other of the additional packages especially *org-ref*
   #+begin_src emacs-lisp
     ;; used the build-in org in emacs 29
     (use-package org
       :straight (:type built-in)
       :config
       (org-babel-do-load-languages
	'org-babel-load-languages
	'((shell . t)
	  (python . t)))
       (setq
	;; editing
	org-auto-align-tags nil
	org-tags-column 0
	org-catch-invisible-edits 'show-and-error
	org-special-ctrl-a/e t
	org-insert-heading-respect-content t
	org-adapt-indentation t

	;; org styling
	org-hide-emphasis-markers nil
	org-pretty-entities t))
   #+end_src
** Easy Gnupg (epg)

   Not sure if this would be required if we've have trusted publick key with private key installed;
   Added since this would help with passphrase key-in.
   #+begin_src emacs-lisp
     ;; allow to input the private key password
     (setf epg-pinentry-mode 'loopback)
   #+end_src

** repeat-mode

   Allows repeat for certain commands such as window resizing and navigating
   #+begin_src emacs-lisp
     ;; enable repeat mode
     (repeat-mode)
   #+end_src

** COMMENT email (gnus)

   A good example [[https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/gnus-guide-en.org][sample]] which includes better configuration in emacs init than the following
   example [[https://www.bounga.org/tips/2020/05/03/multiple-smtp-accounts-in-gnus-without-external-tools/][guide]] on multiple imap use in =gnus=
   #+begin_src emacs-lisp
     (use-package nnhackernews)

     (use-package gnus
       :straight (:type built-in)
       :config
       ;; personal information
       (setq user-full-name "Azizul Rahman Bin Azizan"
	     user-mail-address "azizul80@gmail.com")

       ;; sent via gmail smtp
       (setq message-send-mail-function 'smtpmail-send-it
	     smtpmail-default-smtp-server "smtp1.gmail.com"
	     smtpmail-smtp-service 587
	     smtpmail-local-domain "laptop")

       ;; sort by recent date
       (setq gnus-thread-sort-functions
	     '(gnus-thread-sort-by-most-recent-date
	       (not gnus-thread-sort-by-number)))

       ;; NO 'passive
       (setq gnus-use-cache t)

       ;; Fetch only part of the article if we can.
       ;; I saw this in someone's .gnus
       (setq gnus-read-active-file 'some)

       ;; open attachment
       (eval-after-load 'mailcap
	 '(progn
	    (cond
	     ;; on macOS, maybe change mailcap-mime-data?
	     ((eq system-type 'darwin))
	     ;; on Windows, maybe change mailcap-mime-data?
	     ((eq system-type 'windows-nt))
	     (t
	      ;; Linux, read ~/.mailcap
	      (mailcap-parse-mailcaps)))))

       ;; Tree view for groups.
       (add-hook 'gnus-group-mode-hook 'gnus-topic-mode)

       ;; Threads!  I hate reading un-threaded email -- especially mailing
       ;; lists.  This helps a ton!
       (setq gnus-summary-thread-gathering-function 'gnus-gather-threads-by-subject)

       ;; Also, I prefer to see only the top level message.  If a message has
       ;; several replies or is part of a thread, only show the first message.
       ;; `gnus-thread-ignore-subject' will ignore the subject and
       ;; look at 'In-Reply-To:' and 'References:' headers.
       (setq gnus-thread-hide-subtree t)
       (setq gnus-thread-ignore-subject t)

       ;; Read HTML mail:
       ;; You need install the command line web browser 'w3m' and Emacs plugin 'w3m'
       ;; manually. It specify the html render as w3m so my setup works on all versions
       ;; of Emacs.
       ;;
       ;; Since Emacs 24+, a default html rendering engine `shr' is provided:
       ;;   - It works out of box without any cli program dependency or setup
       ;;   - It can render html color
       ;; So below line is optional.
       ;; (setq mm-text-html-renderer 'w3m)

       ;; http://www.gnu.org/software/emacs/manual/html_node/gnus/_005b9_002e2_005d.html
       (setq gnus-use-correct-string-widths nil)

       ;; newsgroups as primary source
       (setq gnus-select-method '(nntp "news.gmane.io"))
       ;; mails from different servers (imap)
       (add-to-list 'gnus-secondary-select-methods
		    '(nnimap "azizul80"
			     (nnimap-address "imap1.gmail.com")
			     (nnimap-server-port 993)
			     (nnimap-stream ssl)
			     (nnir-search-engine imap)
			     ;; press 'E' to expire email
			     (nnmail-expiry-target "nnimap+gmail:[Gmail]/Trash")
			     (nnmail-expiry-wait 90)))
       (add-to-list 'gnus-secondary-select-methods
		    '(nnimap "azizul.rahman.azizan"
			     (nnimap-address "imap2.gmail.com")
			     (nnimap-server-port 993)
			     (nnimap-stream ssl)
			     (nnir-search-engine imap)
			     (nnmail-expiry-target "nnimap+work-gmail:[Gmail]/Trash")))
       (add-to-list 'gnus-secondary-select-methods
		    '(nnimap "azizul180"
			     (nnimap-address "outlook.office365.com")
			     (nnimap-server-port 993)
			     (nnimap-stream ssl)
			     (nnir-search-engine imap)
			     (nnmail-expiry-wait 90)))
       (add-to-list 'gnus-secondary-select-methods '(nnhackernews ""))


       (eval-after-load 'gnus-topic
	 '(progn
	    (setq gnus-message-archive-group '((format-time-string "sent.%Y")))
	    (setq gnus-server-alist '(("archive" nnfolder "archive" (nnfolder-directory "~/Mail/archive")
				       (nnfolder-active-file "~/Mail/archive/active")
				       (nnfolder-get-new-mail nil)
				       (nnfolder-inhibit-expiry t))))

	    ;; "Gnus" is the root folder topic
	    (setq gnus-topic-topology '(("Gnus" visible)
					(("misc" visible))
					(("news" visible))
					(("mail" visible))
					(("mail draft" visible))))))

       ;; see latest 200 mails in topic hen press Enter on any group
       (gnus-topic-set-parameters "news" '((display . 200)))
       (gnus-topic-set-parameters "mail" '((display . 200)))
       (gnus-topic-set-parameters "mail draft" '((display . 200))))
   #+end_src

* Emacs configuration
** Remap default keybinding

   General keybinding which are troublesome to use such as =C-z= binding which always freeze emacs and
   easy to accidently hit with =C-x= chords.
   #+begin_src emacs-lisp
     ;; remap global command to better ones
     (global-set-key (kbd "C-x C-b") 'ibuffer) ; replace list-buffer

     ;; remove global command "free-frame";
     (global-set-key (kbd "C-z") nil)
   #+end_src
** Map use default function
*** windows swap
    #+begin_src emacs-lisp
      ;; swap between existing windows
      (define-key 'ara-map (kbd "w s") 'window-swap-states)
    #+end_src
** Set the backup file path

   Remove the tilde into default backup file in .emacs directory
   #+begin_src emacs-lisp
     (setq backup-directory-alist '(("." . "~/.emacs.d/backup/"))
	   backup-by-copying t
	   version-control t
	   delete-old-versions t
	   kept-new-versions 10
	   kept-old-versions 5)
     (setq auto-save-file-name-transforms '((".*" "~/.emacs.d/backup/" t)))
   #+end_src

** Basic UI Configuration

   This section configures basic UI settings that remove unneeded elements to make Emacs look a lot
   more minimal and modern.  If you're just getting started in Emacs, the menu bar might be helpful
   so you can remove the =(menu-bar-mode -1)= line if you'd like to still see that.

   #+begin_src emacs-lisp

     (setq inhibit-startup-message t)

     (scroll-bar-mode -1)        ; Disable visible scrollbar
     (tool-bar-mode -1)          ; Disable the toolbar
     (tooltip-mode -1)           ; Disable tooltips
     (set-fringe-mode 10)        ; Give some breathing room

     (menu-bar-mode -1)            ; Disable the menu bar

     ;; Set up the visible bell
     (setq visible-bell t)
     ;; Remove the bell sound in shell
     (setq ring-bell-function 'ignore)

     (column-number-mode)
     ;;(global-display-line-numbers-mode) ; display line number
     (global-hl-line-mode)			    ; horizontal line highlight
     (setq-default fill-column 100) ; line character size
     (global-display-fill-column-indicator-mode) ; vertical column width indicator

     (set-frame-parameter (selected-frame) 'fullscreen 'maximized)
     (add-to-list 'default-frame-alist '(fullscreen . maximized))

     ;; Remove text editing mode in the following
     (dolist (mode '(term-mode-hook
		     shell-mode-hook
		     treemacs-mode-hook
		     eshell-mode-hook
		     vterm-mode-hook))
       (add-hook mode (lambda () (display-fill-column-indicator-mode -1)))) ; vertical ruler


     ;; i-search configuration for matching count
     (setq isearch-lazy-count t)
     ;; i-search matching counter prefix (set to nil)
     (setq lazy-count-prefix-format nil)
     ;; i-search matching counter postfix [x/total] default value
     (setq lazy-count-postfix-format "%s/%s")

     ;; only need to type y/n for yes/no prompt
     (defalias 'yes-or-no-p 'y-or-n-p)

     ;; set the locale to use system (english) for standard use of weekday in english
     (setq system-time-locale "C")

     ;; set default font
     (add-to-list 'default-frame-alist
		  '(font . "JetBrainsMonoNL Nerd Font-10"))

   #+end_src

** Theme
   Separated since the best theme seems to be the default one; however when it gets to shell it's
   irritating! We'll use back the doom theme pack and it's addon.

*** The prequisite icon & themes
    #+begin_src emacs-lisp
      ;; enable the icons for advance themes
      (use-package all-the-icons
	:if (display-graphic-p))
    #+end_src
    Then run the following to install the icons for the first time
    #+begin_src emacs-lisp :tangle no
      (eval (all-the-icons-install-fonts))
    #+end_src
    
*** The main theme
    We'll use the doom megapack for this
    #+begin_src emacs-lisp
      (use-package doom-themes
	:config
	;;global config
	(setq doom-theme-enable-bold t
	      doom-theme-enable-italic t)
	(load-theme 'doom-ayu-dark t)
	(doom-themes-visual-bell-config)
	(doom-themes-org-config))
    #+end_src

*** Themed modeline
    Since we're using doom theme, install as well the modeline for additional information such as
    macro reading & lsp informations
    #+begin_src emacs-lisp
      ;; modeline for additional information
      (use-package doom-modeline
	:init (doom-modeline-mode 1)
	:config
	;; display time when in fullscreen client
	(setq doom-modeline-workspace-name t)
	(display-time-mode))
    #+end_src
    
* General utility
** Git *magit*

   Commonly used distributed SCM, useful for tracking file changes, use =C-x g= to get the magit
   buffer
   #+begin_src emacs-lisp
     ;; auto binded to C-x g
     (use-package magit)
   #+end_src

** Snippet Engine *yasnippet*
   Main snippet engine package
   #+BEGIN_SRC emacs-lisp
     ;; install the snippet template engine
     (use-package yasnippet
       :config
       (setq yas-snippets-dir '("~/.emacs.d/snippets"))
       (yas-global-mode 1))

   #+END_SRC

   For simplicity add the community driven package for the snippet engine
   #+BEGIN_SRC emacs-lisp
     ;; install the community driven snippet template
     (use-package yasnippet-snippets)
   #+END_SRC

** Auto config built-in tree-sitter *treesit-auto*

   With the compiled tree sitter library; we'll need to include the shared parser library and also
   provide mechanism to toggle between tree sitter mode and regular ones (regex); i.e.
   =html-mode= will directly refers to =html-ts-mode= when the parser is available. see the following
   [[https://github.com/renzmann/treesit-auto.git][project]]

   #+BEGIN_SRC emacs-lisp
     ;; use package which uses built-in treesitter and manage major mode compatibility
     (use-package treesit-auto
       :config
       (global-treesit-auto-mode))
   #+END_SRC

** key-binding prompt *which-key*
   #+BEGIN_SRC emacs-lisp
     (use-package which-key
       :defer 0
       :diminish which-key-mode
       :config
       (which-key-mode)
       (setq which-key-idle-delay 1))
   #+END_SRC

** terminal emulator *vterm*

   [[https://github.com/akermu/emacs-libvterm/][vterm]] is an improved terminal emulator package which uses a compiled native module to interact
   with the underlying terminal applications.  This enables it to be much faster than =term-mode=
   and to also provide a more complete terminal emulation experience.

   Make sure that you have the [[https://github.com/akermu/emacs-libvterm/#requirements][necessary dependencies]] installed before trying to use =vterm= because
   there is a module that will need to be compiled before you can use it successfully.

   #+begin_src emacs-lisp

     ;; better terminal emulator
     (use-package vterm
       :commands vterm
       :config
       (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *")  ;; Set this to match your custom shell prompt
       ;;(setq vterm-shell "zsh")                       ;; Set this to customize the shell to launch
       (setq vterm-max-scrollback 10000))

   #+end_src

** regex search *swiper*

   The package are included by *lispy* and its useful.
   #+begin_src emacs-lisp
     (use-package swiper
       :config
       (define-key 'ara-map (kbd "s") 'swiper))
   #+end_src

** jump/hop/util *avy*

   Useful utility are included by *lispy*, however we'll use the jumping to text capability and
   copying based on the same jump/hop mark.
   #+begin_src emacs-lisp
     (use-package avy
       :config
       ;; commonly used
       (global-set-key (kbd "C-:") 'avy-goto-char-timer)
       ;; less frequently used
       (define-key 'ara-map (kbd "g l") 'avy-goto-line)
       (define-key 'ara-map (kbd "g w") 'avy-goto-word-0)
       (define-key 'ara-map (kbd "g c") 'avy-goto-char)
       (define-key 'ara-map (kbd "c l") 'avy-copy-line)
       (define-key 'ara-map (kbd "c r") 'avy-copy-region)
       (define-key 'ara-map (kbd "k l") 'avy-kill-whole-line)
       (define-key 'ara-map (kbd "k r") 'avy-kill-region)
       (define-key 'ara-map (kbd "k L") 'avy-kill-ring-save-whole-line)
       (define-key 'ara-map (kbd "k R") 'avy-kill-ring-save-region))
   #+end_src

** surround eqivalent *smart-parent*
   Add to the personal keymap to process *surround* function to remove the surround char/tag;
   To surround the data, just highlight and add it again.
   #+begin_src emacs-lisp
     ;; use smart-parens
     (use-package smartparens
       :config
       (define-key 'ara-map (kbd "p k") 'sp-splice-sexp)
       (require 'smartparens-config)
       (smartparens-global-mode))
   #+end_src

** minibuffer tags/info *marginalia*
   this is useful package to expand notes on minibuffer; used with *vertico* and *embark*
   #+begin_src emacs-lisp
     ;; enable mini-buffer norrowing framework additional information
     (use-package marginalia
       :config
       (marginalia-mode))
   #+end_src
** context menu anywhere *embark*
   Another useful package which narrows all possible action at cursor point; rather than we have
   to search cursor related information whether it is a function, symbol, file, region this would
   summarizes the possiblilty is drop-down list with shortcuts  for user interaction.

   This would simplify keypress for example selecting a word at cursor for search, opening url etc

   Straight cut and paste from [[https://github.com/oantolin/embark#quick-start][github quick start]]
   #+begin_src emacs-lisp
     (use-package embark
       :bind
       (("C-." . embark-act)         ;; pick some comfortable binding
	("C-;" . embark-dwim)        ;; good alternative: M-.
	("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

       :init

       ;; Optionally replace the key help with a completing-read interface
       ;;(setq prefix-help-command #'embark-prefix-help-command)

       ;; Show the Embark target at point via Eldoc.  You may adjust the Eldoc
       ;; strategy, if you want to see the documentation from multiple providers.
       (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
       ;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)

       :config

       ;; Hide the mode line of the Embark live/completions buffers
       (add-to-list 'display-buffer-alist
		    '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
		      nil
		      (window-parameters (mode-line-format . none)))))
   #+end_src

   Adding integration with *which-key* which exclude the default indicator =embark-verbose-indicator=
   and =embark-mixed-indicator= with the following =embark-which-key-indicator=. 
   #+begin_src emacs-lisp
     (defun embark-which-key-indicator ()
       "An embark indicator that displays keymaps using which-key.
     The which-key help message will show the type and value of the
     current target followed by an ellipsis if there are further
     targets."
       (lambda (&optional keymap targets prefix)
	 (if (null keymap)
	     (which-key--hide-popup-ignore-command)
	   (which-key--show-keymap
	    (if (eq (plist-get (car targets) :type) 'embark-become)
		"Become"
	      (format "Act on %s '%s'%s"
		      (plist-get (car targets) :type)
		      (embark--truncate-target (plist-get (car targets) :target))
		      (if (cdr targets) "…" "")))
	    (if prefix
		(pcase (lookup-key keymap prefix 'accept-default)
		  ((and (pred keymapp) km) km)
		  (_ (key-binding prefix 'accept-default)))
	      keymap)
	    nil nil t (lambda (binding)
			(not (string-suffix-p "-argument" (cdr binding))))))))

     (setq embark-indicators
	   '(embark-which-key-indicator
	     embark-highlight-indicator
	     embark-isearch-highlight-indicator))

     (defun embark-hide-which-key-indicator (fn &rest args)
       "Hide the which-key indicator immediately when using the completing-read prompter."
       (which-key--hide-popup-ignore-command)
       (let ((embark-indicators
	      (remq #'embark-which-key-indicator embark-indicators)))
	 (apply fn args)))

     (advice-add #'embark-completing-read-prompter
		 :around #'embark-hide-which-key-indicator)
   #+end_src

   For *consult* we'll add the following code
   #+begin_src emacs-lisp
     ;; Consult users will also want the embark-consult package.
     (use-package embark-consult
       :ensure t ; only need to install it, embark loads it after consult if found
       :hook
       (embark-collect-mode . consult-preview-at-point-mode))
   #+end_src

   #+RESULTS:
   
** narrowing list *vertico*
   ;; code and paste from the [[https://github.com/minad/vertico#configuration][url]]
   #+begin_src emacs-lisp
     ;; Enable vertico
     (use-package vertico
       :init
       (vertico-mode)

       ;; Different scroll margin
       ;; (setq vertico-scroll-margin 0)

       ;; Show more candidates
       ;; (setq vertico-count 20)

       ;; Grow and shrink the Vertico minibuffer
       ;; (setq vertico-resize t)

       ;; Optionally enable cycling for `vertico-next' and `vertico-previous'.
       ;; (setq vertico-cycle t)
       )

     ;; Persist history over Emacs restarts. Vertico sorts by history position.
     (use-package savehist
       :init
       (savehist-mode))

     ;; A few more useful configurations...
     (use-package emacs
       :init
       ;; Add prompt indicator to `completing-read-multiple'.
       ;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
       (defun crm-indicator (args)
	 (cons (format "[CRM%s] %s"
		       (replace-regexp-in-string
			"\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
			crm-separator)
		       (car args))
	       (cdr args)))
       (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

       ;; Do not allow the cursor in the minibuffer prompt
       (setq minibuffer-prompt-properties
	     '(read-only t cursor-intangible t face minibuffer-prompt))
       (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

       ;; Emacs 28: Hide commands in M-x which do not work in the current mode.
       ;; Vertico commands are hidden in normal buffers.
       ;; (setq read-extended-command-predicate
       ;;       #'command-completion-default-include-p)

       ;; Enable recursive minibuffers
       (setq enable-recursive-minibuffers t))
   #+end_src

** Code completion *company*

   Company actually improves the usage of =completion-at-point= function to be very polished (drop
   downlist); This would be used in conjunction for general narrowing framework (ivy, helm, vertico,
   odorless) since company provide completion at buffer with integration of the backend such as lsp,
   major mode provided completion and other suchs tags
   #+begin_src emacs-lisp
     ;; install company and enable it on global level
     (use-package company
       :config
       (global-company-mode))
   #+end_src

** narrowing or completion filter *oderless*
   This would make narrowing better such as matching not in order.
   #+begin_src emacs-lisp
     ;; make narrowing or completion better like fuzzy finder
     (use-package orderless
       :ensure t
       :custom
       (completion-styles '(orderless basic))
       (completion-category-overrides '((file (styles basic partial-completion)))))
   #+end_src

** emacs enhanced command with fuzzy finder *consult*
   Since most of emacs function such as viewing register, macro or buffer doesn't include search;
   adding this would make sense as looking at yank register is cumbersome while filter with fuzzy
   finder on buffer list make sense on buffer switching. In general it's better to replace all the
   existing function!!

   Note copy paste directly from [[https://github.com/minad/consult][Github page]]; also *embark* provides the consult integration which
   should be installed as well.
   #+begin_src emacs-lisp
     ;; enhance existing emacs with consult
     ;; Example configuration for Consult
     (use-package consult
       ;; Replace bindings. Lazily loaded due by `use-package'.
       :bind (;; C-c bindings in `mode-specific-map'
	      ("C-c M-x" . consult-mode-command)
	      ("C-c h" . consult-history)
	      ("C-c q" . consult-kmacro) ;; originally C-c k
	      ("C-c m" . consult-man)
	      ("C-c i" . consult-info)
	      ([remap Info-search] . consult-info)
	      ;; C-x bindings in `ctl-x-map'
	      ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
	      ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
	      ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
	      ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
	      ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
	      ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
	      ;; Custom M-# bindings for fast register access
	      ("M-#" . consult-register-load)
	      ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
	      ("C-M-#" . consult-register)
	      ;; Other custom bindings
	      ("M-y" . consult-yank-pop)                ;; orig. yank-pop
	      ;; M-g bindings in `goto-map'
	      ("M-g e" . consult-compile-error)
	      ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
	      ("M-g g" . consult-goto-line)             ;; orig. goto-line
	      ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
	      ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
	      ("M-g m" . consult-mark)
	      ("M-g k" . consult-global-mark)
	      ("M-g i" . consult-imenu)
	      ("M-g I" . consult-imenu-multi)
	      ;; M-s bindings in `search-map'
	      ("M-s d" . consult-find)                  ;; Alternative: consult-fd
	      ("M-s D" . consult-locate)
	      ("M-s g" . consult-grep)
	      ("M-s G" . consult-git-grep)
	      ("M-s r" . consult-ripgrep)
	      ("M-s l" . consult-line)
	      ("M-s L" . consult-line-multi)
	      ("M-s k" . consult-keep-lines)
	      ("M-s u" . consult-focus-lines)
	      ;; Isearch integration
	      ("M-s e" . consult-isearch-history)
	      :map isearch-mode-map
	      ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
	      ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
	      ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
	      ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
	      ;; Minibuffer history
	      :map minibuffer-local-map
	      ("M-s" . consult-history)                 ;; orig. next-matching-history-element
	      ("M-r" . consult-history))                ;; orig. previous-matching-history-element

       ;; Enable automatic preview at point in the *Completions* buffer. This is
       ;; relevant when you use the default completion UI.
       :hook (completion-list-mode . consult-preview-at-point-mode)

       ;; The :init configuration is always executed (Not lazy)
       :init

       ;; Optionally configure the register formatting. This improves the register
       ;; preview for `consult-register', `consult-register-load',
       ;; `consult-register-store' and the Emacs built-ins.
       (setq register-preview-delay 0.5
	     register-preview-function #'consult-register-format)

       ;; Optionally tweak the register preview window.
       ;; This adds thin lines, sorting and hides the mode line of the window.
       (advice-add #'register-preview :override #'consult-register-window)

       ;; Use Consult to select xref locations with preview
       (setq xref-show-xrefs-function #'consult-xref
	     xref-show-definitions-function #'consult-xref)

       ;; Configure other variables and modes in the :config section,
       ;; after lazily loading the package.
       :config

       ;; Optionally configure preview. The default value
       ;; is 'any, such that any key triggers the preview.
       ;; (setq consult-preview-key 'any)
       ;; (setq consult-preview-key "M-.")
       ;; (setq consult-preview-key '("S-<down>" "S-<up>"))
       ;; For some commands and buffer sources it is useful to configure the
       ;; :preview-key on a per-command basis using the `consult-customize' macro.
       (consult-customize
	consult-theme :preview-key '(:debounce 0.2 any)
	consult-ripgrep consult-git-grep consult-grep
	consult-bookmark consult-recent-file consult-xref
	consult--source-bookmark consult--source-file-register
	consult--source-recent-file consult--source-project-recent-file
	;; :preview-key "M-."
	:preview-key '(:debounce 0.4 any))

       ;; Optionally configure the narrowing key.
       ;; Both < and C-+ work reasonably well.
       (setq consult-narrow-key "<") ;; "C-+"

       ;; Optionally make narrowing help available in the minibuffer.
       ;; You may want to use `embark-prefix-help-command' or which-key instead.
       ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

       ;; By default `consult-project-function' uses `project-root' from project.el.
       ;; Optionally configure a different project root function.
       ;;;; 1. project.el (the default)
       ;; (setq consult-project-function #'consult--default-project--function)
       ;;;; 2. vc.el (vc-root-dir)
       ;; (setq consult-project-function (lambda (_) (vc-root-dir)))
       ;;;; 3. locate-dominating-file
       ;; (setq consult-project-function (lambda (_) (locate-dominating-file "." ".git")))
       ;;;; 4. projectile.el (projectile-project-root)
       ;; (autoload 'projectile-project-root "projectile")
       ;; (setq consult-project-function (lambda (_) (projectile-project-root)))
       ;;;; 5. No project support
       ;; (setq consult-project-function nil)
       )
   #+end_src

* Documents
** pdf *pdf-tools*
   After installation, need to run =(pdf-tools-install)= which will built the server it connects to.
   With *nixos* this will download the built dependencies automatically and built the server binary.
   #+begin_src emacs-lisp
     ;; viewing pdf
     (use-package pdf-tools)
   #+end_src
* Modal key binding *meow*
  modal editing similar to kakoune (vim inspired)
** Defining default #+setupfile: up taken from the example for QWERTY
   Keybinding configuration for the different states; the normal state is the place to *learn* where
   the normal keys excluding control, meta can be rebinded to meow specific function; allowing
   better navigation without control and meta key combination.  The only changes is to modify text,
   we need to move to *Insert* mode. *Insert* state means all keybinds are literal minus the control
   and meta key, with escape key usually bind to excape to *Normal* mode. For input command with
   control, meta combination; *Keypad* mode is useful to input shortcut to emacs style chording
   without overriding any of them. The *Beacon* state still alien so skipping this one yet, but it
   seems to be useful for multi cursor implementation.

*** Motion state
    Applicable to special buffer such as Dired, Proced. No changes to default
*** Normal state
    For normal state this allow modal navigation while still enabling the default emacs binding,
    however certain meow commands such meow-insert, meow-append, meow-change, meow-open-below,
    meow-open-above will change to insert state.

    #+begin_src emacs-lisp
      ;; key binding specific to normal state
      (defun ara/meow-normal-define-key ()
	(meow-normal-define-key
	 '("0" . meow-expand-0)
	 '("9" . meow-expand-9)
	 '("8" . meow-expand-8)
	 '("7" . meow-expand-7)
	 '("6" . meow-expand-6)
	 '("5" . meow-expand-5)
	 '("4" . meow-expand-4)
	 '("3" . meow-expand-3)
	 '("2" . meow-expand-2)
	 '("1" . meow-expand-1)
	 '("-" . negative-argument)
	 '(";" . meow-reverse)
	 '("," . meow-inner-of-thing)
	 '("." . meow-bounds-of-thing)
	 '("[" . meow-beginning-of-thing)
	 '("]" . meow-end-of-thing)
	 '("a" . meow-append)
	 '("A" . meow-open-below)
	 '("b" . meow-back-word)
	 '("B" . meow-back-symbol)
	 '("c" . meow-change)
	 '("d" . meow-delete)
	 '("D" . meow-backward-delete)
	 '("e" . meow-next-word)
	 '("E" . meow-next-symbol)
	 '("f" . meow-find)
	 '("g" . meow-cancel-selection)
	 '("G" . meow-grab)
	 '("h" . meow-left)
	 '("H" . meow-left-expand)
	 '("i" . meow-insert)
	 '("I" . meow-open-above)
	 '("j" . meow-next)
	 '("J" . meow-next-expand)
	 '("k" . meow-prev)
	 '("K" . meow-prev-expand)
	 '("l" . meow-right)
	 '("L" . meow-right-expand)
	 '("m" . meow-join)
	 '("n" . meow-search)
	 '("o" . meow-block)
	 '("O" . meow-to-block)
	 '("p" . meow-yank)
	 '("q" . meow-quit)
	 '("Q" . meow-goto-line)
	 '("r" . meow-replace)
	 '("R" . meow-swap-grab)
	 '("s" . meow-kill)
	 '("t" . meow-till)
	 '("u" . meow-undo)
	 '("U" . meow-undo-in-selection)
	 '("v" . meow-visit)
	 '("w" . meow-mark-word)
	 '("W" . meow-mark-symbol)
	 '("x" . meow-line)
	 '("X" . meow-goto-line)
	 '("y" . meow-save)
	 '("Y" . meow-sync-grab)
	 '("z" . meow-pop-selection)
	 '("'" . repeat)
	 '("<escape>" . ignore))
	)
    #+end_src
*** Insert state
    Literal keyboard keys, minus control and meta key. Escape should be quiting to *NORMAL* state.
*** Keypad state
    Default control and meta shortcuts using space keys, in summary:
    | keys typed          | key expanded | command description          |
    |---------------------+--------------+------------------------------|
    | <Space> x h         | <C-x> h      | Select whole buffer          |
    | <Space> g \         | <C-M-\>      | Indent selected region       |
    | <Space> x s         | <C-x> <C-s>  | Save current file            |
    | <Space> x <Space> b | <C-x> b      | Switch buffer in mini-buffer |
    | <Space> m g [ g     | <M-g> g      | Go to line *                 |
    |                     |              |                              |

    Note some are longer than the prefix, either use that or check if meow function has been bind
    in *NORMAL* state. Some command like switching buffer above, requires more command since
    it additional keys for shortcuts in secondary prefixes.

*** Beacon state
*** General setup
    Add the individual state key binding to general key binding and setup
    #+begin_src emacs-lisp
      ;; meow general setup function this is call before mode are enabled locally or globally
      (defun ara/meow-setup ()
	(setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty)
	(meow-motion-overwrite-define-key
	 '("j" . meow-next)
	 '("k" . meow-prev)
	 '("<escape>" . ignore))
	(meow-leader-define-key
	 ;; SPC j/k will run the original command in MOTION state.
	 '("j" . "H-j")
	 '("k" . "H-k")
	 ;; Use SPC (0-9) for digit arguments.
	 '("1" . meow-digit-argument)
	 '("2" . meow-digit-argument)
	 '("3" . meow-digit-argument)
	 '("4" . meow-digit-argument)
	 '("5" . meow-digit-argument)
	 '("6" . meow-digit-argument)
	 '("7" . meow-digit-argument)
	 '("8" . meow-digit-argument)
	 '("9" . meow-digit-argument)
	 '("0" . meow-digit-argument)
	 '("/" . meow-keypad-describe-key)
	 '("?" . meow-cheatsheet))
	(ara/meow-normal-define-key))
    #+end_src

** load *meow* bindings
   #+begin_src emacs-lisp
     ;; configure meow with local setup binding
     (use-package meow
       :config
       (ara/meow-setup)
       (meow-global-mode 1))
   #+end_src

* COMMENT Modal key binding *evil*

  Using selection based know seem more tedious; trying out evil-mode with less configuration.
  Too much modification on the software sides
  #+begin_src emacs-lisp
    (use-package evil
      :config

      ;; evil mode leader should work only for normal,
      (evil-set-leader 'normal (kbd "SPC"))
      ;; shortcut for evil <C-c a> for personal keybind
      (evil-define-key 'normal 'global (kbd "<leader>a") 'ara-map)

      ;; use org-mode standard cycling heading
      (evil-define-key 'normal org-mode-map (kbd "<tab>") #'org-cycle)
      (evil-mode 1)

      ;; plugin
      (use-package evil-surround
	:config
	(global-evil-surround-mode)))

  #+end_src
* Programming
** Workspace management

   Used the built-in project, the key map is =C-x p=

   Without
   #+begin_src emacs-lisp
     (use-package project
       :straight (:type built-in ))
   #+end_src

** Eglot

   Used the build-in eglot library; note the eglot has it's own default programs configured
   #+begin_src emacs-lisp
     (use-package eglot
       :straight (:type built-in))
   #+end_src

** Language
*** Clojure

    For steps is to include the major mode editing for clojure files; this is is using [[https://github.com/clojure-emacs/clojure-mode][clojure-mode]]
    #+begin_src emacs-lisp
      ;; major mode for clojure editing
      (use-package clojure-mode)
    #+end_src

    Then we include the interactive development package using [[https://cider.mx/][cider]] which should gave us similar
    editing like common-lisp and sly integration.
    #+begin_src emacs-lisp
      ;; clojure interactive development
      (use-package cider)
    #+end_src

*** Typescript

    #+begin_src emacs-lisp

      ;; programming typescript with lsp
      (use-package typescript-mode
	:mode "\\.ts\\'"
	:config
	(setq typescript-indent-level 2))

    #+end_src

    *Important note!* For =lsp-mode= to work with TypeScript (and JavaScript) you will need to
    install a language server on your machine.  If you have Node.js installed, the easiest way to do
    that is by running the following command:

    #+begin_src shell :tangle no

      npm install -g typescript-language-server typescript

    #+end_src

    This will install the [[https://github.com/theia-ide/typescript-language-server][typescript-language-server]] and the TypeScript compiler package.
*** Python

    We use =lsp-mode= and =dap-mode= to provide a more complete development environment for Python
    in Emacs.  Check out [[https://emacs-lsp.github.io/lsp-mode/page/lsp-pyls/][the =pyls= configuration]] in the =lsp-mode= documentation for more details.

    Make sure you have the =pyls= language server installed before trying =lsp-mode=!

    #+begin_src sh :tangle no

      pip install --user "python-language-server[all]"

    #+end_src

    There are a number of other language servers for Python so if you find that =pyls= doesn't work
    for you, consult the =lsp-mode= [[https://emacs-lsp.github.io/lsp-mode/page/languages/][language configuration documentation]] to try the others!

    #+begin_src emacs-lisp
      ;; install python + lsp
      (use-package python-mode)
    #+end_src

*** Zig

    Simple installation of getting the binary compiler and placing it in the =PATH=. Once installed
    we can build the lsp server made from Zig =zls= and using the integration with =lsp-mode=
    package.
    - zls :: Get the source code and build it using git; see [[https://github.com/zigtools/zls][link]]
    - zig-mode :: Zig major mode for syntax highlighting
      #+begin_src emacs-lisp
	;; install main mode with lsp integrated with zls
	(use-package zig-mode)
      #+end_src

*** C and C++

    *eglot* has some default configuration; seems to work fast enough

*** Rust

    Depends on the tree-sitter for syntax highlighting and LSP for advanced options
    #+begin_src emacs-lisp
      ;; add rust + lsp
      (use-package rust-mode
	:hook ((rust-mode . (lambda ()(setq indent-tabs-mode nil)))
	       (rust-mode . (lambda ()(prettify-symbols-mode))))
	:config
	(setq rust-format-on-save t))
    #+end_src

*** Common Lisp
**** SLY

     SLIME forked should work better with auto completion; Similar to SLIME this is independent of LSP and DAP.
     Refer to the following [[https://github.com/joaotavora/sly][link]] for the modification and manual (similar to SLIME but with additional features).
     #+begin_src emacs-lisp
       ;; SLIME forked version sly with sbcl dialect
       (use-package sly
	 :config
	 (setq inferior-lisp-program "sbcl"))
     #+end_src

*** Emacs Lisp (elisp)
**** Another paraedit *lispy*

     Abo-abo package which work well for lisp dialects
     #+BEGIN_SRC emacs-lisp
       ;; updated version of paredit from abo-abo
       (use-package lispy
	 :config
	 :hook ((emacs-lisp-mode . (lambda ()(lispy-mode 1)))
		(lisp-mode . (lambda ()(lispy-mode 1)))))
       ;; need formatter to save time
       ;; (use-package elisp-format); takes to long to format a buffer
     #+END_SRC

*** Nix (system builder)
    #+begin_src emacs-lisp
      ;; install the major mode
      (use-package nix-mode
	:mode "\\.nix\\'"
	:config
	(add-to-list 'eglot-server-programs '(nix-mode . ("/media/debian-home/zizu/git-repo/github/grp-nix-community/nixd/result/bin/nixd"))))

    #+end_src

*** Haskell
    Use the ghc with the major mode, where *hs-lint* is included in the major mode.
    #+begin_src emacs-lisp
      ;; install haskell-mode
      (use-package haskell-mode)
    #+end_src
*** Ocaml
    For installation and setup of ocaml toolchains, see the following [[https://ocaml.org/docs/up-and-running][link]]. The primary tools are:
    - opam :: package manager
    - merlin :: ide support
    - dune :: build tool
    - utop :: repl

**** opam merlin installation output emacs config guide
     Since we are using the repository to install the merline integration the output of opam merlin
     can be simplified to use-pacage config

     #+begin_src emacs-lisp :tangle no
       ;; baseline config which imports general config in opam/default/share
       ;; Add opam emacs directory to your load-path by appending this to your .emacs:
       (let ((opam-share (ignore-errors (car (process-lines "opam" "var" "share")))))
	 (when (and opam-share (file-directory-p opam-share))
	   ;; Register Merlin
	   (add-to-list 'load-path (expand-file-name "emacs/site-lisp" opam-share))
	   (autoload 'merlin-mode "merlin" nil t nil)
	   ;; Automatically start it in OCaml buffers
	   (add-hook 'tuareg-mode-hook 'merlin-mode t)
	   (add-hook 'caml-mode-hook 'merlin-mode t)
	   ;; Use opam switch to lookup ocamlmerlin binary
	   (setq merlin-command 'opam)))

       ;; add the major mode hook required above
     #+end_src
**** use-package equivalent setup
     Following the installation from the [[https://batsov.com/articles/2022/08/23/setting-up-emacs-for-ocaml-development/][link]] which uses use-package only
     #+begin_src emacs-lisp
       (use-package merlin
	 :hook ((tuareg-mode . merlin-mode)
		(caml-mode . merlin-mode)
		(merlin-mode . company-mode))
	 :config
	 (setq merlin-command 'opam))

       ;; ocaml major mode
       (use-package tuareg)

       ;; ocaml dune config file major mode
       (use-package dune)

       ;; merlin documentation
       (use-package merlin-eldoc
	 :hook (tuareg-mode . merlin-eldoc-setup))

       ;; use merlin internal
       (use-package flycheck-ocaml
	 :config
	 (flycheck-ocaml-setup))

       (use-package utop
	 :hook
	 (tuareg-mode . utop-minor-mode))
     #+end_src
*** Erlang
    For installation of latest OTP (erlang build) use the distribution list provided at
    [[https://www.erlang-solutions.com/downloads/][erlang-solutions]].  Once installed the command to activate otp is =erl=. The installation of
    specific otp version will also include emacs integration mode scripts. =erl= command is an
    emulator (virtual machine).
    #+begin_src sh :tangle no :results output
      wget https://packages.erlang-solutions.com/erlang-solutions_2.0_all.deb
      sudo dpkg -i erlang-solutions_2.0_all.deb
      sudo apt-get update
      sudo apt-get install erlang
    #+end_src

    Not sure will be using this in *nixos* environment, since FHS in not available
    #+begin_src emacs-lisp :tangle no
      ;; load installed provided OTP erlang mode library
      (setq load-path (cons "/usr/lib/erlang/lib/tools-3.5.3/emacs" load-path))
      (setq erlang-root-dir "/usr/lib/erlang/")
      (setq exec-path (cons "/usr/lib/erlang/bin" exec-path))
      (require 'erlang-start)
    #+end_src

    Use the default major mode
    #+begin_src emacs-lisp
      ;; erlang major mode
      (use-package erlang)
    #+end_src
   

*** Elixir
    Once setup has bee done to update the latest =apt= repository from =Erlang Solutions=, we can
    install elixir via following command.
    #+begin_src sh :tangle no :results output
      sudo apt-get update
      sudo apt-get install elixir
    #+end_src

    Then we build the [[https://github.com/elixir-lsp/elixir-ls][language server]] to integrate with emacs =lsp-mode= which provided dap
    debugging, in contrast with the built-in =eglot= library. The =elixir-ls= server is written in
    elixir itself.  Here are some of the installed toolchains (installed at =/usr/lib/elixir/bin=);
    - elixir :: script runner
    - elixirrc :: compiler
    - mix :: software package management tool
    - iex :: elixir shell

      #+begin_src emacs-lisp :tangle no
	;; install elixir major mode with lsp-mode integration
	(use-package elixir-mode
	  :init
	  (add-to-list 'exec-path "~/apps/elixir-ls/release"))
      #+end_src

    For usage with *nixos*, used the cached binary directly in the configuration file
    #+begin_src emacs-lisp
      ;; add elixir major mode with elixir-ls on path
      (use-package elixir-mode)
    #+end_src
